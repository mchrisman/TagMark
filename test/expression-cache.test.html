<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Test: Expression cache</title>
  <script src="../lib/deep_proxy.js"></script>
  <script src="../lib/ActDown.js"></script>
  <script src="../lib/ActDown-ext-forms.js"></script>
  <script src="../src/tagmark.js"></script>
  <script src="./_harness.js"></script>
</head>
<body>

<h1>Expression cache</h1>
<div id="test-results" data-status="pending"></div>

<script>
Test.run("expression-cache", t => {
  TagMark.ready(() => {
    TagMarkDebug.resetExprCache();

    const scope = TagMarkDebug.createScope();
    scope.setHandle('Global', new TagMarkDebug.Handle('global'));
    scope.setValue('$x', 1);
    TagMark.namespaces.global.value = 10;

    const expr = '@Global.value + $x';

    const first = TagMark.evalPure(expr, scope);
    scope.setValue('$x', 2);
    const second = TagMark.evalPure(expr, scope);
    const stats1 = TagMarkDebug.getExprCacheStats();

    t.eq(first, 11, 'first eval reads handles and values');
    t.eq(second, 12, 'second eval reuses compiled function with new values');
    t.eq(stats1.compiled, 1, 'compiled once for identical handle set');
    t.eq(stats1.cacheSize, 1, 'single cache entry stored');

    scope.setHandle('Extra', new TagMarkDebug.Handle('global', ['extra']));
    TagMark.evalPure(expr, scope);
    const stats2 = TagMarkDebug.getExprCacheStats();
    t.eq(stats2.compiled, 2, 'adding handle forces recompilation');
    t.eq(stats2.cacheSize, 2, 'cache tracks handle-aware entries');

    TagMarkDebug.resetExprCache();
    t.done();
  });
});
</script>

</body>
</html>
